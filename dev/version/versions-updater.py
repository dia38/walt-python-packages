#!/usr/bin/env python
import sys, os, subprocess, hashlib
sys.path.append(os.getcwd())
from dev.api.source import SourceImporter
from dev.tools.pretty import pprint_dict

versions_file_template = """\
# auto-generated by dev/version/versions-updater.py

API_VERSIONING = %(api_versioning)s

UPLOAD = %(upload)s
"""

# instanciate our source import system and activate it.
importer = SourceImporter({ 'walt.common': './common/walt/common' })
importer.activate()
from walt.common.versions import API_VERSIONING as CUR_API_VERSIONING, \
                                 UPLOAD as CUR_UPLOAD
# retrieve API hash using dev/api/explorer.py
# for each component (client, server, node), compare
# with what we had before and increment the api version
# if it changed.
API_PATH = {
    'SERVER': 'walt.server.daemon',
    'CLIENT': 'walt.client.client',
    'NODE': 'walt.node.daemon'
}

new_api_versioning = CUR_API_VERSIONING.copy() # for now
new_upload = CUR_UPLOAD + 1     # we increment at each upload

for component, module_path in API_PATH.items():
    new_api_proto = subprocess.check_output(
        [ 'dev/api/explorer.py', module_path ])
    new_api_hash = hashlib.sha224(new_api_proto).hexdigest()
    cur_api_num, cur_api_hash = CUR_API_VERSIONING[component]
    if cur_api_hash != new_api_hash:
        # API of this component as changed, increment api_num
        # and update hash for next time.
        new_api_versioning[component] = (cur_api_num+1, new_api_hash)

new_versions_file = versions_file_template % dict(
    api_versioning = pprint_dict(new_api_versioning),
    upload = new_upload
)

# write updated info in walt/common/versions.py
with open("common/walt/common/versions.py", "w") as f:
    f.write(new_versions_file)

