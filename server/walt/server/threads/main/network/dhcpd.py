#!/usr/bin/env python
from walt.server import const
from walt.server.threads.main.network.tools import ip, net, get_walt_subnet
from operator import itemgetter
from itertools import groupby
from walt.server.threads.main.images.image import get_mount_path
from walt.common.tools import do

DHCPD_CONF_FILE = '/etc/dhcp/dhcpd.conf'

CONF_PATTERN = """
#
# DO NOT EDIT THIS FILE
#
# It is automatically generated by the walt system 
# and updated when needed.
#

# global parameters
authoritative; # allow sending DHCP NAKs
next-server %(walt_server_ip)s;
option broadcast-address %(subnet_broadcast)s;

# walt unregistered devices
subnet %(subnet_ip)s netmask %(subnet_netmask)s {
    # declare ranges of unallocated addresses
%(walt_unallocated_ranges_conf)s

    # check if the ip is already used
    ping-check = 1;

    # no need to recheck often if you are now registered
    min-lease-time 6000000;
    max-lease-time 6000000;
    default-lease-time 6000000;

    # get the vendor class identifier if available
    if exists vendor-class-identifier {
        set vci = option vendor-class-identifier;
    } else {
        set vci = "";
    }

    # when we assign a new IP address, let walt register
    # this new device
    on commit {
        set ip_string = binary-to-ascii(10, 8, ".", leased-address);
        # note: we ensure all 6 bytes of the mac address are left padded with 0 if needed
        # (binary-to-ascii would not output '0e' but just 'e').
        set mac_address_string = concat (
            suffix (concat ("0", binary-to-ascii (16, 8, "", substring(hardware,1,1))),2), ":",
            suffix (concat ("0", binary-to-ascii (16, 8, "", substring(hardware,2,1))),2), ":",
            suffix (concat ("0", binary-to-ascii (16, 8, "", substring(hardware,3,1))),2), ":",
            suffix (concat ("0", binary-to-ascii (16, 8, "", substring(hardware,4,1))),2), ":",
            suffix (concat ("0", binary-to-ascii (16, 8, "", substring(hardware,5,1))),2), ":",
            suffix (concat ("0", binary-to-ascii (16, 8, "", substring(hardware,6,1))),2)
        );
        execute("/usr/local/bin/walt-dhcp-event", "commit", vci,
                        ip_string, mac_address_string);
    }
}

# walt registered devices
%(walt_registered_devices_conf)s
"""

RANGE_CONF_PATTERN = "    range %(first)s %(last)s;"

NODE_CONF_PATTERN = """\
host %(hostname)s {
    hardware ethernet %(mac)s;
    fixed-address %(ip)s;
    option host-name "%(hostname)s";
}
"""

SWITCH_CONF_PATTERN = """\
host %(hostname)s {
    hardware ethernet %(mac)s;
    fixed-address %(ip)s;
}
"""

# see http://stackoverflow.com/questions/2154249/identify-groups-of-continuous-numbers-in-a-list
def get_contiguous_ranges(ips):
    ranges=[]
    for k, g in groupby(enumerate(ips), lambda (i,x):i-int(x)):
        group = map(itemgetter(1), g)
        ranges.append((group[0], group[-1]))
    return ranges

def generate_dhcpd_conf(devices):
    subnet = get_walt_subnet()
    devices_confs = []
    free_ips = list(subnet.hosts())
    server_ip = free_ips.pop(0)
    for device_info in devices:
        if device_info['type'] == 'switch':
            conf_pattern = SWITCH_CONF_PATTERN
        else:
            conf_pattern = NODE_CONF_PATTERN
        devices_confs.append(conf_pattern % device_info)
        free_ips.remove(ip(device_info['ip']))
    range_confs = []
    for r in get_contiguous_ranges(free_ips):
        first, last = r
        range_confs.append(\
            RANGE_CONF_PATTERN % dict(
                    first=first,
                    last=last
        ))
    infos = dict(
        walt_server_ip=server_ip,
        subnet_ip=subnet.network_address,
        subnet_broadcast=subnet.broadcast_address,
        subnet_netmask=subnet.netmask,
        walt_registered_devices_conf='\n'.join(devices_confs),
        walt_unallocated_ranges_conf='\n'.join(range_confs)
    )
    return CONF_PATTERN % infos

QUERY_DEVICES_WITH_IP="""
    SELECT * FROM devices WHERE ip IS NOT NULL ORDER BY mac;
"""

class DHCPServer(object):
    def __init__(self, db):
        self.db = db
    def update(self, force=False):
        devices = []
        for item in \
                self.db.execute(QUERY_DEVICES_WITH_IP).fetchall():
            device_type = item.type
            device_mac = item.mac
            if device_type != 'server':
                devices.append(dict(
                    type=item.type,
                    hostname=item.name,
                    ip=item.ip,
                    mac=device_mac))
        conf = generate_dhcpd_conf(devices)
        with open(DHCPD_CONF_FILE, 'r') as conf_file:
            old_conf = conf_file.read()
        if conf != old_conf:
            with open(DHCPD_CONF_FILE, 'w') as conf_file:
                conf_file.write(conf)
            force = True # perform the restart below
        if force == True:
            do('service isc-dhcp-server restart')
            print 'dhcpd conf updated.'

